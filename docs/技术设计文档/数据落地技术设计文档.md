# 存储：数据捞起（热加载）与脏数据落地 技术设计文档

本文档梳理 `homo-core-storage-redis-mysql`、`homo-core-storage-dirty-redis`、`homo-core-storage-landing-mysql` 与 `com.homo.core.facade.storege` 下抽象接口之间的协作机制，系统阐述设计思想、流程、主要类与职责、捞取与落地规则，帮助理解与演进该方案。

---

## 1. 设计思想（Design Philosophy）

目标：在高并发游戏场景下，兼顾读写性能与存储一致性，降低数据库压力，支撑可观测的、可恢复的落地链路。

核心理念：
- 读写分离：读优先走缓存，写先写缓存，再异步落地数据库。
- 事件溯源：将“变更点”（field 级变更）记录到脏表（DirtyMap），由专职落地程序批处理落地。
- 热加载（捞起）：当缓存没有命中时，从数据库“捞起”冷数据填充到缓存，复用统一结构（HSet）。
- 一致性分层：强一致需求限定在单 Key 的读-改-写路径，最终一致由落地保证；可通过锁与版本字段（up_version）增强幂等。
- 可演进：脏表快照、失败错误表、批/单模式降级、可插拔落地策略，便于扩展与排错。

---

## 2. 总体架构与数据流

```text
  业务层（ByteStorage/ObjStorage 调用）
          │
          ▼
  StorageDriver（Redis 读、写、incr、remove）
          │                       ┌───────────┐
          │  写入/自增/删除  ─────▶│ DirtyDriver│ 记录变更字段
          │                       └───────────┘
          │                                 │
   读（命中）│                                 │定时/抢锁
          ▼                                 ▼
      Redis(HSet)                   Landing程序（LandingDriver）
          │                                 │
   读（未命中）│                                 │批量/单条落地
          ▼                                 ▼
  LandingDriver.hot* ──────►  MySQL（DataObject 表模型）
       （热加载）                   （冷数据与最新落地）
```

关键点：
- 缓存结构使用 Redis Hash（HSet），Key 维度为 `appId:regionId:logicType:ownerId`，field 为具体逻辑键（logicKey）。
- 写操作：Redis HSet 更新 + 脏表（DirtyMap）记录变更字段；不直接同步 DB。
- 落地程序：负责从脏表扫描变更，批量写 DB；失败切单条，仍失败转错误表以待人工/补偿。
- 捞起：缓存未命中时，从 DB 读取对应 owner 的所有字段/指定字段，并回填 Redis 再次读取。

---

## 3. 模块与类职责（Class Responsibility）

### 3.1 Facade 抽象（com.homo.core.facade.storege）
- `StorageDriver`
  - 抽象统一的存储接口：`asyncGetByFields/asyncGetAll/asyncUpdate/asyncIncr/asyncRemoveKeys`
  - 由 `homo-core-storage-redis-mysql` 提供具体实现（Redis 一致结构 + 脏标记）。
- `DirtyDriver`
  - 脏数据记录与迭代接口：`dirtyUpdate/chooseDirtyMap/lockDirtyMap/snapShot/landing/...`
  - 由 `homo-core-storage-dirty-redis` 提供 Redis 脏表实现。
- `LandingDriver<T>`
  - 热加载与落地：`hotAllField/hotFields/batchLanding/singleLanding`
  - 由 `homo-core-storage-landing-mysql` 使用 MySQL 承载冷数据与落地逻辑。
- `SaveObject`
  - 面向 `ObjStorage` 的对象抽象，包含 `getLogicType/getOwnerId`。

### 3.2 业务向 API（homo-core-storage）
- `ByteStorage`
  - 面向字节级 KV 的存取封装，组合 `StorageDriver` 实现。
- `ObjStorage`
  - 面向可序列化对象的存取封装，组合 `ByteStorage` 与序列化器。

### 3.3 MySQL 表模型（示意）
- `DataObject`
  - 字段：`primary_key`（logicType:ownerId:key）、`logic_type`、`owner_id`、`key`、`value(BLOB)`、`up_version`、`is_del`、时间戳等。
  - 索引：主键、`query_all_key`（logicType:ownerId）。

---

## 4. Redis 键模型与命名
- 数据键（HSet）：`slug-data:{appId:regionId:logicType:ownerId}`
- 缓存全量标志 field（建议）：`cachedAllKey`（表示 owner 下所有字段已加载）
- 逻辑删除标记：`{logicKey}:delFlag`（或移至 `{logicKey}:del` 备份域）
- 脏表（HSet 集合名）：按 `homo.dirty.tableNum` 拆分，如 `dirtyKey:0..N`
- 脏表快照名：`{dirtyKey}:saving`
- 错误表名：`{dirtyKey}:error`

---

## 5. 写入与脏记录流程（Update/Incr/Remove）

```text
业务调用 → StorageDriver.asyncUpdate/asyncIncr/asyncRemoveKeys
  1) 写 Redis HSet（slug-data）
  2) 记录 DirtyMap（ownerId + logicKey 列表）
  3) 返回（不阻塞 DB）
```

要点：
- 写入 Redis 成功即返回，收敛写放大与尾延迟。
- DirtyMap 以 field 粒度记录，便于落地最小化 SQL 集合。
- Incr 使用 Lua 或原子命令，避免竞态；对应落地以最终值为准。

---

## 6. 热加载/捞起（Hot Load）流程

场景：读缓存未命中或 `cachedAllKey` 缺失。

```text
  ByteStorage.get(...fields)
   ├─ 命中：直接返回
   └─ 未命中：LandingDriver.hotFields/hotAllField(appId, regionId, logicType, ownerId, redisKey, fields)
        1) 从 DB 读取 ownerId 的字段（按 fields 或全量）
        2) 回填 Redis HSet（slug-data）
        3) 重试读取 Redis 并返回
```

规则：
- 单字段读优先 `hotFields`，大量字段或首次读可用 `hotAllField` 填充并设置 `cachedAllKey`。
- DB → Redis 回填必须一次性写入 Hash 中，对应 field 与元信息（如 `cachedAllKey`）。

---

## 7. 脏数据落地（Landing）流程

```text
定时/守护进程：
  for each dirtyMap in round-robin:
    if lockDirtyMap(dirtyMap):
       snapshot = snapShot(dirtyMap)       # 原子重命名，写时复制
       while true:
         dirtyList = getDirtyList(snapshot, cursor, batchSize)
         if empty: break
         if batchLanding(snapshot, dirtyList) == false:
            # 降级单条
            singleLanding(dirtyList, snapshot)
       unlockDirtyMap(dirtyMap)
```

规则：
- 竞争控制：`lockDirtyMap` 确保同一脏表同一时刻仅一个落地实例处理。
- 快照：`snapShot` 将当前脏表重命名为 `saving`，与写入隔离；新写入继续落入原表。
- 批处理：优先批量构造 SQL（insert on duplicate/update），失败降级单条；仍失败则写入错误表。
- 幂等：以 `primary_key` + `up_version` 控制并发覆盖；删除标记需要与时间戳配合。

---

## 8. 一致性与并发控制
- 读一致性：读 Redis 缓存，若冷数据，捞起回填再读；避免直接击穿 DB。
- 写一致性：缓存为准，DB 异步最终一致；通过 `up_version`（或乐观锁）避免回放覆盖。
- 自增幂等：incr 以 Redis 结果为准，落地时写最终值；避免重复累加。
- 删除逻辑：逻辑删除标记与时间戳，落地时转换为持久层删除/置位。

---

## 9. 失败与恢复
- 批落地失败 → 单条；单条失败 → 错误表（errorMap）。
- 错误表巡检：提供运维工具/任务，将异常数据重新落地或导出人工修复。
- 监控指标：落地速率、失败率、错误表规模、平均批量大小、Redis 命中率。

---

## 10. 流程图（ASCII）

写入与脏标记：
```text
   update/incr/remove
        │
        ▼
  Redis HSet 写入 ──► DirtyMap 记录（ownerId:logicKey）
        │
        └── 返回（异步最终一致）
```

捞起（未命中）：
```text
   读取 Redis 未命中
        │
        ▼
 LandingDriver.hot* 从 DB 读 → 回填 Redis → 再读返回
```

落地：
```text
  锁定 dirtyMap → 快照 saving → HSCAN 批量 → 批量 SQL → 失败降级单条 → 失败记录 errorMap
```

---

## 11. 关键类图（逻辑）
```text
+------------------+        +------------------+
|  ByteStorage     |        |  ObjStorage      |
|  - storageDriver |        |  - byteStorage   |
+--------+---------+        +---------+--------+
         |                             |
         v                             v
+------------------+        +------------------+
|  StorageDriver   |<------>|  DirtyDriver     |
|  (Redis facade)  |        |  (Redis dirty)   |
+--------+---------+        +---------+--------+
         |                             
         v                             
+------------------------------+
|  LandingDriver (MySQL)       |
|  hotAll/hotFields/landing    |
+------------------------------+
```

---

## 12. 规则明细（Checklist）
- Redis HSet Key：`slug-data:{appId:regionId:logicType:ownerId}`；field 为具体逻辑键。
- 脏记录规模控制：按 `homo.dirty.tableNum` 分表；落地实例轮询+加锁。
- 快照语义：确保落地对稳定视图处理，避免与新写入竞争。
- 批量 SQL：优先使用 `INSERT ... ON DUPLICATE KEY UPDATE` 或批量 UPDATE；注意包体大小与事务控制。
- 自增与版本：落地侧以最终值写入，`up_version` 做乐观并发控制。
- 删除：逻辑删除落地时转持久层删除或置 `is_del=1`，保留 `del_time`。
- 回填缓存：捞起后必须回填 Redis 再读取，减少后续打 DB。
- 监控：QPS、Redis 命中、落地延迟、脏表堆积、失败率、错误表大小。

---

## 13. 参考实现/配置（摘录）
- `StorageDriver.REDIS_KEY_TMPL = "slug-data:{%s:%s:%s:%s}"`
- `DirtyProperties`：`tableNum/table.prefix/snapshot.suffix/error.suffix/landing.batchNum/landing.delayTime`
- MySQL 表模型参考 `DataObject`：`primary_key/logic_type/owner_id/key/value/up_version/is_del/...`

---

## 14. 演进路线
- 引入多租户/分库分表策略：扩展 `TableDivideStrategy`
- 引入 Binlog 校验与回补：落地后对比缓存/DB 校验差异
- 落地幂等强化：对同一 primaryKey/版本冲突时聚合更新
- 错误表自动回放策略：带节流/指数退避

---

## 15. 附录：术语
- 捞起/热加载（Hot Load）：从持久层将冷数据加载回缓存。
- 脏数据（Dirty）：尚未落地到持久层的变更集合。
- 脏表（DirtyMap）：记录变更字段的集合（Redis HSet）。
- 快照（Snapshot）：对脏表做写时复制，确保落地数据视图稳定。
